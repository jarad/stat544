\documentclass[handout,xcolor=pdftex,dvipsnames,table]{beamer} % for handouts
%\documentclass{beamer}




\usecolortheme[RGB={0,0,144}]{structure}
\usetheme{AnnArbor}\usecolortheme{beaver}
%\usetheme{CambridgeUS}\usecolortheme{crane}

\usepackage{verbatim,xmpmulti,color,multicol,multirow}
\setlength{\unitlength}{\textwidth}  % measure in textwidths
\usepackage[normalem]{ulem}

%\usepackage{beamerthemesplit}
\setbeamertemplate{navigation symbols}{}
%\setbeamercolor{alerted text}{fg=red}
%\setbeamertemplate{block body theorem}{bg=orange}
\setkeys{Gin}{width=0.6\textwidth}


\title{Probit regression}
\subtitle{Genotypic fungal resistance}
\author[Jarad Niemi]{Dr. Jarad Niemi}
\institute[Iowa State]{Iowa State University}
\date{\today}

\newcommand{\mG}{\mathrm{\Gamma}}
\newcommand{\I}{\mathrm{I}}
\newcommand{\mySigma}{\mathrm{\Sigma}}
\newcommand{\myPhi}{\mathrm{\Phi}}

\begin{document}

<<chunk_options, echo=FALSE, message=FALSE>>=
require(knitr) # only needed so the following command does not fail when sourcing R code
opts_chunk$set(fig.width=6, fig.height=5, out.width='.8\\linewidth', fig.align='center', size='tiny', message=FALSE)
##############################################
# GLMMs                                      #
##############################################
require(reshape2)
require(plyr)
require(ggplot2)
require(rstan)
set.seed(20140424)
@

\frame{\maketitle}

\begin{frame}
\frametitle{Probit regression}
Consider the model
\[ Y_i \stackrel{ind}{\sim} Ber(\theta_i) \]
where, for the $i$th observation, 
\begin{itemize}[<+->]
\item $Y_i$ is binary indicating \emph{success} and
\item $\theta_i$ is the probability of success.
\end{itemize}

A probit regression model assumes 
\[ \theta_i = \myPhi(X_i^\top\beta) \]
where 
\begin{itemize}
\item $X_i$ are the explanatory variables for the $i$th observation,
\item $\myPhi$ is the standard normal cumulative distribution function, and 
\item $\beta$ is the vector of parameters to be estimated.
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Low birth weight}
<<birthwt>>=
library(MASS)
birthwt$race = factor(birthwt$race)
summary(birthwt)
birthwt$age  = with(birthwt, (age-mean(age))/sd(age))
birthwt$lwt  = with(birthwt, (lwt-mean(lwt))/sd(lwt))
@
\end{frame}


\begin{frame}[fragile]
<<non-Bayesian>>=
m = glm(low~., family=binomial(link=probit), data=birthwt[,-10])
summary(m)
@
\end{frame}

\section{Bayesian analysis}
\begin{frame}
\frametitle{Probit regression}
Consider the model
\[ \begin{array}{rl}
Y_i &\stackrel{ind}{\sim} Bin(n_i,\theta_i) \\
\theta_i &= \myPhi(X_i^\top\beta)
\end{array}  \]

 \pause

with prior 
\[ \beta \sim N(\beta_0,\mySigma_\beta) \]

\pause

The posterior distribution is 
\[ \begin{array}{rl}
p(\beta|y) &\propto p(y|\beta)p(\beta) \\
&\propto \prod_{i=1}^n \myPhi(X_i'\beta)^{y_i}[1-\myPhi(X_i'\beta)]^{n_i-y_i} e^{-(\beta-\beta_0)^\top\mySigma_\beta^{-1}(\beta-\beta_0)} 
\end{array} \]
\pause But neither $p(\beta|y)$ nor $p(\beta_p|y,\beta_{-p})$ are a known distribution.
\end{frame}




\subsection{Data augmentation}
\begin{frame}
\frametitle{Data augmentation}
An alternative construction of the model is 
\[ \begin{array}{rl}
Y_i &= \I(Z_i>0) \\
Z_i &\stackrel{ind}{\sim} N(X_i'\beta,1)
\end{array} \]
Note that 
\[ \begin{array}{rll}
\theta_i 
&= Pr(Y_i=1) \\
&= Pr(Z_i>0) \\
&= Pr(X_i'\beta+\epsilon>0) & \epsilon \sim N(0,1) \\
&= Pr(\epsilon>X_i'\beta) \\
&= Pr(\epsilon<X_i'\beta) & \mbox{symmetry of standard normal} \\
&= \myPhi(X_i'\beta) 
\end{array} \]
Thus, this is equivalent to the probit regression model.
\end{frame}




\begin{frame}
\frametitle{Posterior distribution}

Now, the full data likelihood is 
\[ p(y|Z) \propto \prod_{i=1}^n \left[\I(Z_i>0)\I(y_i=1)+\I(Z_i\le 0)\I(y_i=0)\right] \]
and priors
\[ Z_i \stackrel{ind}{\sim} N(X_i'\beta,1) \qquad \beta\sim N(\beta_0,\mySigma_\beta) \]
%and thus the full posterior is 
%\[ p(\beta,Z|y) \propto \prod_{i=1}^n N(Z_i|X_i'\beta,1)\left[\I(Z_i>0)\I(y_i=1)+\I(Z_i\le 0)\I(y_i=0)\right] \]

Thus the posterior distribution is 
\[ p(\beta,Z|y) \propto p(y|Z,\beta) p(\beta) = p(y|Z) p(Z|\beta) p(\beta) \]
and we will derive the full conditionals for $p(\beta|Z,y)$ and $p(Z|\beta,y)$. 
\end{frame}


\begin{frame}
\frametitle{Full conditional for $\beta$}

The full conditional for $\beta$ is 
\[ \begin{array}{rl}
p(\beta|\ldots) \propto& p(y|Z) p(Z|\beta) p(\beta) \\
=& \prod_{i=1}^n N(Z_i|X_i'\beta,1)\left[\I(Z_i>0)\I(y_i=1)+\I(Z_i\le 0)\I(y_i=0)\right] \\
&\times N(\beta|\beta_0,\mySigma_\beta) \\
\propto& N(Z|X\beta,\I) N(\beta|\beta_0,\mySigma_\beta)  
\end{array} \]
and thus 
$\beta|\ldots \sim N(\hat{\beta},\hat{\mySigma}_\beta)$ with 

\[ \begin{array}{rl}
\hat{\mySigma}_\beta &= [\mySigma_\beta^{-1} + X^\top X]^{-1} \\
\hat{\beta} &= \hat{\mySigma}_\beta [\mySigma_\beta^{-1}\beta_0 + X^\top Z]
\end{array} \]

\end{frame}

\begin{frame}
\frametitle{Full conditional for $Z$}

The full conditional for $Z$ is 
\[ \begin{array}{rl}
p(Z|\ldots) \propto& p(y|Z) p(Z|\beta) p(\beta) \\
=& \prod_{i=1}^n N(Z_i|X_i'\beta,1)\left[\I(Z_i>0)\I(y_i=1)+\I(Z_i\le 0)\I(y_i=0)\right] \\
&\times N(\beta|\beta_0,\mySigma_\beta) \\
\propto& \prod_{i=1}^n N(Z_i|X_i'\beta,1)\left[\I(Z_i>0)\I(y_i=1)+\I(Z_i\le 0)\I(y_i=0)\right]
\end{array} \]
Thus the $Z_i$ are conditionally independent with distribution 
\[ p(Z_i|Y_i,\beta) = \left\{ \begin{array}{rl}
N(Z_i|X_i'\beta,1)\I(Z_i>0) & \mbox{if } y_i=1 \\
N(Z_i|X_i'\beta,1)\I(Z_i\le 0) & \mbox{if } y_i=0
\end{array} \right. \]

\end{frame}



\begin{frame}[fragile]
<<mcmc, cache=TRUE>>=
mcmc = function(n_iter, y, X, beta0, Sigma_beta) {
  n = nrow(X)
  p = ncol(X)
  
  # Precalculate quantities
  y = (as.numeric(y)==1)
  n1 = sum( y)
  n0 = sum(!y)
  XX = t(X)%*%X
  Si = solve(Sigma_beta)
  Sib = Si%*%beta0
  
  # Saving structures
  beta_keep       = matrix(NA, n_iter, p)
  Z_keep          = matrix(NA, n_iter, n)
  
  # Initial values
  m = glm(y~X-1, family=binomial(probit))
  beta = coef(m)
  Z = rep(NA,n)
  
  for (i in 1:n_iter) {
    # Sample Z
    Xb = X%*%beta
    cut = pnorm(0,Xb)
    Z[ y] = qnorm(runif(n1, cut[ y], 1), Xb[ y], 1)
    Z[!y] = qnorm(runif(n0, 0, cut[!y]), Xb[!y], 1)
    
    # Sample beta
    S_hat = solve(Si+XX)
    b_hat = S_hat %*% (Sib+t(X)%*%Z)
    beta = mvrnorm(1, b_hat, S_hat)
    
    # Record values
    beta_keep[i,] = beta
    Z_keep[i,]    = Z
  }
  
  return(list(beta = beta_keep, Z = Z_keep))
}
@
\end{frame}



\begin{frame}[fragile]
<<run_mcmc, dependson="mcmc", cache=TRUE>>=
X = model.matrix(m) # Constructs the design matrix
p = ncol(X)
out = mcmc(1000, birthwt$low, X, rep(0,p), 3*diag(p))
colnames(out$beta) = colnames(X)
@
\end{frame}


\begin{frame}[fragile]
<<traceplots, dependson="run_mcmc">>=
par(mfrow=c(2,5))
for (i in 1:p) plot(out$beta[,i], main=colnames(X)[i],xlab='iteration', type='l')
@
\end{frame}


\begin{frame}[fragile]
<<acf, dependson="run_mcmc">>=
par(mfrow=c(2,5))
for (i in 1:p) acf(out$beta[,i], main=colnames(X)[i])
@
\end{frame}


\begin{frame}[fragile]
<<ess, dependson="run_mcmc">>=
require(coda)
require(mcmcse)
adply(out$beta, 2, function(x) {
  data.frame(ess_coda = round(effectiveSize(x)),
             ess_mcmcse = round(ess(x)),
             lb = round(quantile(x, .025),2),
             ub = round(quantile(x, .975),2))
})
@
\end{frame}




\section{Probit regression with random effects}
\begin{frame}
\frametitle{Probit regression with random effects}
Consider the probit regression model 
\[ \begin{array}{rl}
Y_i &= \I(Z_i>0) \\
Z &\sim N(\tilde{X}\tilde{\beta}, 1)
\end{array} \]
where 
\[ \tilde{X} = [X\quad Z] \qquad \tilde{\beta} = (\beta, u)^\top \]
and $u\sim N(0,\sigma^2 \I)$ and $\sigma\sim Unif(0,10)$. \pause Thus the prior on $\tilde{\beta}$ is 
\[ \tilde{\beta} = \left( \begin{array}{c} \beta \\ u 
\end{array} \right) \sim N\left(\left[\begin{array}{c} \beta_0 \\ 0   \end{array} \right], \left[ \begin{array}{cc} \mySigma_\beta & 0 \\ 0 & \sigma^2 \I
\end{array} \right] \right) \]
\pause 
where the precision of the prior is 
\[ \left[ \begin{array}{cc} \mySigma_\beta^{-1} & 0 \\ 0 & \frac{1}{\sigma^2} \I
\end{array} \right] \]
\end{frame}

\begin{frame}
\frametitle{Full posterior}

The full posterior is 
\[ 
p(Z,\beta,y,\sigma^2|y) \propto p(y|Z)p(Z|\tilde{\beta})p(\tilde{\beta}|\sigma^2)p(\sigma^2) 
\]

\pause

We have already derived the full conditionals 
\begin{itemize}
\item $p(\tilde{\beta}|\ldots)$
\item $p(Z|\ldots)$
\end{itemize}
\pause 
but we need the full conditional for $\sigma^2$. 
\end{frame}


\begin{frame}
\frametitle{Full conditional for $\sigma^2$}

\[ \begin{array}{rl}
p(\sigma^2|\ldots) &\propto p(y|Z)p(Z|\tilde{\beta})p(\tilde{\beta}|\sigma^2)p(\sigma^2) \\
&= p(\tilde{\beta}|\sigma^2)p(\sigma^2) \\
&\propto p(u|\sigma^2)p(\sigma^2) \\
&\propto \prod_{u=1}^U N(u_i|0,\sigma^2) \frac{1}{\sigma}\I(0,100) \\
&\propto (\sigma^2)^{-U/2} e^{-\frac{1}{2\sigma^2}u'u} (\sigma^2)^{-1/2}\I(0,100)  \\
&= (\sigma^2)^{-\frac{U-1}{2}-1}e^{-\frac{1}{2\sigma^2}u'u}\I(0,100) 
\end{array} \]
Thus $\sigma^2 \sim IG([U-1]/2, -u'u/2)$ truncated to be smaller than 100. 

\end{frame}




\begin{frame}[fragile]
<<corn_fungus, fig.width=8>>=
d = read.csv("cornFungus.csv")
d$block = factor(d$block)
ggplot(d, aes(y=hypha/spore, x=genotype, col=block))+geom_point()
@
\end{frame}


\begin{frame}[fragile]
<<corn_fungus_glmer>>=
require(lme4)
m = glmer(cbind(hypha,spore-hypha)~block+genotype+(1|pot), 
          family=binomial(probit), d,
          control=glmerControl(optimizer="bobyqa")) # Avoids convergence warning
summary(m)
@
\end{frame}




\begin{frame}[fragile]
<<mcmc_random_effects>>=
mcmc = function(n_iter, y, X, Zm, beta0, Sigma_beta) {
  require(Matrix)
  n = nrow(X)
  p = ncol(X)
  q = ncol(Z)
  
  # Initial values
  m = glm(y~X-1, family=binomial(probit))
  beta = c(coef(m),rep(0,q))
  Z = rep(NA,n)
  
  # Precalculate quantities
  y = (as.numeric(y)==1)
  n1 = sum( y)
  n0 = sum(!y)
  X  = cbind(X,Zm)
  XX = t(X)%*%X
  Si = solve(Sigma_beta)
  Sib = Si%*%beta0
  a = (q-1)/2
  
  # Saving structures
  beta_keep  = matrix(NA, n_iter, p)
  u_keep     = matrix(NA, n_iter, q)
  sigma_keep = rep(NA, n_iter)
  
  for (i in 1:n_iter) {
    # Sample Z
    Xb = X%*%beta
    cut = pnorm(0,as.numeric(Xb))
    Z[ y] = qnorm(runif(n1, cut[ y], 1), Xb[ y], 1)
    Z[!y] = qnorm(runif(n0, 0, cut[!y]), Xb[!y], 1)
    
    # Sample sigma
    u = beta[p+1:q]
    b = sum(u^2)/2
    sigma2 = 1/qgamma(runif(1,0,pgamma(100,a,b)),a,b)
    
    # Sample beta
    SSi = bdiag(Si,diag(q)/sigma2)
    S_hat = solve(SSi+XX)
    b_hat = S_hat %*% (rbind(Sib,matrix(0,q,1))+t(X)%*%Z)
    beta = mvrnorm(1, b_hat, S_hat)
    
    # Record values
    beta_keep[i,]  = beta[1:p]
    u_keep[i,]     = u
    sigma_keep[i] = sqrt(sigma2)
  }
  
  return(list(beta  = beta_keep,  
              sigma = sigma_keep, 
              u = u_keep))
}
@
\end{frame}


\begin{frame}[fragile]
<<run_mcmc_random, cache=TRUE>>=
# Turn into binary data
dd = ddply(d, .(genotype,block,leaf,pot), function(x) {
  data.frame(y=c(rep(1,x$hypha),rep(0,x$spore-x$hypha)))
})

m = glmer(y~genotype+block+(1|pot), family=binomial(probit), dd)

X = model.matrix(m)
Z = as.matrix(getME(m,"Z"))
p = ncol(X)
system.time(out <- mcmc(1000, dd$y, X, Z, rep(0,p), diag(p)))
colnames(out$beta) = colnames(X)
@
\end{frame}



\begin{frame}[fragile]
<<traceplots2, dependson="run_mcmc_random">>=
par(mfrow=c(2,3))
for (i in 1:p) plot(out$beta[,i], main=colnames(X)[i],xlab='iteration', type='l')
@
\end{frame}


\begin{frame}[fragile]
<<acf2, dependson="run_mcmc_random">>=
par(mfrow=c(2,3))
for (i in 1:p) acf(out$beta[,i], main=colnames(X)[i])
@
\end{frame}


\begin{frame}[fragile]
<<ess2, dependson="run_mcmc_random">>=
require(coda)
require(mcmcse)
adply(out$beta, 2, function(x) {
  data.frame(ess_coda = round(effectiveSize(x)),
             ess_mcmcse = round(ess(x)),
             lb = round(quantile(x, .025),2),
             ub = round(quantile(x, .975),2))
})
@
\end{frame}





\end{document}